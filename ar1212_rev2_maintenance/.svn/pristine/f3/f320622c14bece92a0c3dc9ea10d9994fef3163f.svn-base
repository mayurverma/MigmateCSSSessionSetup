#######################################################################################
# Copyright 2018 ON Semiconductor.  All rights reserved.
#
# This software and/or documentation is licensed by ON Semiconductor under limited
# terms and conditions.  The terms and conditions pertaining to the software and/or
# documentation are available at http://www.onsemi.com/site/pdf/ONSEMI_T&C.pdf
# ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Softwar").
# Do not use this software and/or documentation unless you have carefully read and
# you agree to the limited terms and conditions.  By using this software and/or
# documentation, you agree to the limited terms and conditions.
########################################################################################
#
# Generates Assembler, C and Python firmware fatal error header files from a master CSV file
#
########################################################################################
import argparse
import csv
import os
import sys

class FatalErrorGenerator():
    """Fatal Error header generator class
    """

    ASM_HEADER = \
        ';***********************************************************************************\n' \
        '; Copyright 2018 ON Semiconductor.  All rights reserved.\n' \
        ';\n' \
        '; This software and/or documentation is licensed by ON Semiconductor under limited\n' \
        '; terms and conditions. The terms and conditions pertaining to the software and/or\n' \
        '; documentation are available at http://www.onsemi.com/site/pdf/ONSEMI_T&C.pdf\n' \
        '; ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Software").\n' \
        '; Do not use this software and/or documentation unless you have carefully read and\n' \
        '; you agree to the limited terms and conditions. By using this software and/or\n' \
        '; documentation, you agree to the limited terms and conditions.\n' \
        ';***********************************************************************************\n' \
        '\n' \
        ';!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' \
        '; DO NOT EDIT - This file is auto-generated by the generate_fatal_errors.py script\n' \
        ';!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' \
        '\n' \
        ';-------------------------------------------------------------------------------\n' \
        ';                               Fatal Error Codes\n' \
        ';-------------------------------------------------------------------------------\n'


    ASM_FOOTER = \
        '\n' \
        '                END\n'

    C_HEADER = \
        '#ifndef SRC__SYSTEMMGR__INC__SYSTEMMGR_FATAL_ERROR\n' \
        '#define SRC__SYSTEMMGR__INC__SYSTEMMGR_FATAL_ERROR\n' \
        '//***********************************************************************************\n' \
        '/// \\file\n' \
        '///\n' \
        '/// Fatal error codes.\n' \
        '///\n' \
        '//***********************************************************************************\n' \
        '// Copyright 2018 ON Semiconductor.  All rights reserved.\n' \
        '//\n' \
        '// This software and/or documentation is licensed by ON Semiconductor under limited\n' \
        '// terms and conditions. The terms and conditions pertaining to the software and/or\n' \
        '// documentation are available at http://www.onsemi.com/site/pdf/ONSEMI_T&C.pdf\n' \
        '// ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Software").\n' \
        '// Do not use this software and/or documentation unless you have carefully read and\n' \
        '// you agree to the limited terms and conditions. By using this software and/or\n' \
        '// documentation, you agree to the limited terms and conditions.\n' \
        '//***********************************************************************************\n' \
        '\n' \
        '// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' \
        '// DO NOT EDIT - This file is auto-generated by the generate_fatal_errors.py script\n' \
        '// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' \
        '\n' \
        '//------------------------------------------------------------------------------\n' \
        '//                               Fatal Error Codes\n' \
        '//------------------------------------------------------------------------------\n' \
        '\n' \
        '// *INDENT-OFF*\n' \
        '\n' \
        '/// Fatal error codes\n' \
        'typedef enum\n' \
        '{'

    C_FOOTER = \
        '} SystemMgrFatalErrorT;\n' \
        '\n' \
        '#endif /* SRC__SYSTEMMGR__INC__SYSTEMMGR_FATAL_ERROR */\n' \
        '\n'

    PYTHON_HEADER = \
        '####################################################################################\n' \
        '# Copyright 2018 ON Semiconductor.  All rights reserved.\n' \
        '#\n' \
        '# This software and/or documentation is licensed by ON Semiconductor under limited\n' \
        '# terms and conditions. The terms and conditions pertaining to the software and/or\n' \
        '# documentation are available at http://www.onsemi.com/site/pdf/ONSEMI_T&C.pdf\n' \
        '# ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Software").\n' \
        '# Do not use this software and/or documentation unless you have carefully read and\n' \
        '# you agree to the limited terms and conditions. By using this software and/or\n' \
        '# documentation, you agree to the limited terms and conditions.\n' \
        '#\n' \
        '####################################################################################\n' \
        '\n' \
        '#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' \
        '# DO NOT EDIT - This file is auto-generated by the generate_fatal_errors.py script\n' \
        '#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' \
        '\n' \
        'from enum import IntEnum, unique\n' \
        '\n' \
        '@unique\n' \
        'class SystemMgrFatalError(IntEnum):\n' \
        '    """Fatal error enumeration."""\n'

    PYTHON_FOOTER = \
        '\n' \
        '    def __str__(self):\n' \
        '        return \'0x{:04X}:{}\'.format(self.value, self.name)\n' \
        '\n'

    def __init__(self, csv_filename, prefix, debug=False):
        self._csv_filename = csv_filename
        self._prefix = prefix
        self._debug = debug

    def validate(self):
        """Checks for duplicate values
        """
        if self._debug: print("Validating values...")
        found_values = list()

        with open(self._csv_filename, newline='') as csvfile:
            input_values = csv.DictReader(csvfile)
            for row in input_values:
                if "" != row['Name'].strip():
                    value_name = row['Name'].strip()
                    value_code = int(row['Value'].strip(), 16)

                    if self._debug: print("Evaluating value: {}: {}".format(value_name, value_code))

                    # Look for a duplicate
                    for (existing_value_code, existing_value_name) in found_values:
                        if existing_value_code == value_code:
                            raise Exception("Duplicate code found: {} duplicates {}\n".format(value_name, existing_value_name))

                    found_values.append((value_code, value_name))

        if self._debug: print("All values valid\n")

    def generate_asm(self, filename):
        """Generates the Assembler .inc header file.
        """
        if self._debug:
            print("Generating assembler values...")

        # Build the ASM content
        content = self.ASM_HEADER

        with open(self._csv_filename, newline='') as csvfile:
            values = csv.DictReader(csvfile)
            next_value = 1
            for row in values:
                if "" != row['Name'].strip():
                    if int(row['Value'].strip(), 16) != next_value:
                        content += '\n'
                        next_value = int(row['Value'].strip(), 16) + 1
                    else:
                        next_value += 1
                    content += "{}_{:45s} EQU {:5s} ; ({}) {}\n".format(self._prefix, \
                        row['Name'].strip(), row['Value'].strip(), int(row['Value'].strip(), 16), row['Comment'].strip())

        content += self.ASM_FOOTER

        # write the ASM content
        if self._debug: print("Writing {}...".format(filename))
        with open(filename, "wt", newline='\n') as ostream:
            ostream.write(content)

    def generate_c(self, filename):
        """Generates the C .h header file.
        """
        if self._debug:
            print("Generating C values...")

        # Build the C content
        content = self.C_HEADER

        with open(self._csv_filename, newline='') as csvfile:
            values = csv.DictReader(csvfile)
            next_value = 1
            for row in values:
                if "" != row['Name'].strip():
                    if int(row['Value'].strip(), 16) != next_value:
                        content += '\n'
                        next_value = int(row['Value'].strip(), 16) + 1
                    else:
                        next_value += 1
                    nameValue = '{}_{} = {}U,'.format(self._prefix, row['Name'].strip(), row['Value'].strip())
                    content += "    {:87s} ///< ({}) {}\n".format(\
                        nameValue, int(row['Value'].strip(), 16), row['Comment'].strip())

        content += self.C_FOOTER

        # write the C content
        if self._debug: print("Writing {}...".format(filename))
        with open(filename, "wt", newline='\n') as ostream:
            ostream.write(content)

    def generate_python(self, filename):
        """Generates the Python .py header file.
        """
        if self._debug:
            print("Generating Python values...")

        # Build the Python content
        content = self.PYTHON_HEADER

        with open(self._csv_filename, newline='') as csvfile:
            values = csv.DictReader(csvfile)
            next_value = 1
            for row in values:
                if "" != row['Name'].strip():
                    if int(row['Value'].strip(), 16) != next_value:
                        content += '\n'
                        next_value = int(row['Value'].strip(), 16) + 1
                    else:
                        next_value += 1
                    nameValue = '    {} = {}'.format(row['Name'].strip(), row['Value'].strip())
                    content += "{:55s}  # ({}) {}\n".format(\
                        nameValue, int(row['Value'].strip(), 16), row['Comment'].strip())

        content += self.PYTHON_FOOTER

        # write the Python content
        if self._debug: print("Writing {}...".format(filename))
        with open(filename, "wt", newline='\n') as ostream:
            ostream.write(content)

# Create the argument parser
parser = argparse.ArgumentParser(prog='generate_fatal_errors',
    description='Generate Assembler, C and Python header files for System Manager fatal errors')
parser.add_argument('-d', '--debug', default=False, action='store_true', help='Enable debug output')
parser.add_argument('-c', '--csvfile', required=True, help='Fatal Error master CSV file')
parser.add_argument('-o', '--output', required=True, help='Output directory for ASM and C header files')
parser.add_argument('-s', '--scripts', required=True, help='Output directory for Python scripts')
parser.add_argument('-v', '--validate', required=False, action='store_true', help='Validate fatal errors')

# Parse the command line arguments
args = parser.parse_args()

generator = FatalErrorGenerator(args.csvfile, 'SYSTEM_MGR_FATAL_ERROR', args.debug)
if args.validate:
    generator.validate()

# Generate ASM, C and Python header files
print('Generating fatal errors...')
generator.generate_asm(os.path.join(args.output, 'SystemMgrFatalError.inc'))
generator.generate_c(os.path.join(args.output, 'SystemMgrFatalError.h'))
generator.generate_python(os.path.join(args.scripts, 'systemmgr_fatal_error.py'))
