#######################################################################################
# Copyright 2018 ON Semiconductor.  All rights reserved.
#
# This software and/or documentation is licensed by ON Semiconductor under limited
# terms and conditions.  The terms and conditions pertaining to the software and/or
# documentation are available at http://www.onsemi.com/site/pdf/ONSEMI_T&C.pdf
# ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Softwar").
# Do not use this software and/or documentation unless you have carefully read and
# you agree to the limited terms and conditions.  By using this software and/or
# documentation, you agree to the limited terms and conditions.
########################################################################################
#
# Generates C header files with the key database for Depu App
#
########################################################################################
import argparse
import csv
import os
import sys
import struct
# Add Python libraries to the import search path
rootdir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
scripts_dir = os.path.join(rootdir, 'scripts')
test_scripts_dir = os.path.join(rootdir, 'test/scripts')

if scripts_dir not in sys.path:
    sys.path.append(scripts_dir)

if test_scripts_dir not in sys.path:
    sys.path.append(test_scripts_dir)

from crypto_helper import CryptoHelper
from crypto_services_client import CryptoServicesClient
from rsa_public_certificate import RSAPublicCertificate, CertificatePurpose
from host_command_provision_asset import HostCommandProvisionAssetParams
from key_name import KeyName
from root_of_trust import RootOfTrust
from branch_properties import BranchProperties

class DepuCertGenerator():
    """Depu content generator class
    """

    PYTHON_HEADER = \
        '####################################################################################\n' \
        '# Copyright 2018 ON Semiconductor.  All rights reserved.\n' \
        '#\n' \
        '# This software and/or documentation is licensed by ON Semiconductor under limited\n' \
        '# terms and conditions. The terms and conditions pertaining to the software and/or\n' \
        '# documentation are available at http://www.onsemi.com/site/pdf/ONSEMI_T&C.pdf\n' \
        '# ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Software").\n' \
        '# Do not use this software and/or documentation unless you have carefully read and\n' \
        '# you agree to the limited terms and conditions. By using this software and/or\n' \
        '# documentation, you agree to the limited terms and conditions.\n' \
        '#\n' \
        '####################################################################################\n' \
        '\n' \
        '#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' \
        '# DO NOT EDIT - This file is auto-generated by the generate_depu_certificates.py script\n' \
        '#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' \
        '\n'

    def __init__(self, key_set_name,   debug=False):

        self._crypto_cm = CryptoServicesClient(BranchProperties.get_product_prefix(), root_of_trust = RootOfTrust.CM, key_set_name = key_set_name)
        self._debug = debug

    def _bytes_to_hex(self, data, comment = False):
        """prints bytes to ascii
        """
        result = ""
        for index, databyte in enumerate(data):
            if (index % 16) == 0:
                result += "\n#   " if comment else " \n    "
            else:
                result += " "
            result += "0x{:02x},".format(databyte)

        return result

    def _print_bytes(self, name, params_bytes):

        content = ""
        content += "\n# {} {} bytes\n".format(name, len(params_bytes))
        content += self._bytes_to_hex(params_bytes)
        content += "\n"

        return content

    def _generate_certificate(self, key_name, key_name_signing, purpose, version, number):

        content = ""
        root_of_trust = 0 # RoT CM

        rsa_key = self._crypto_cm.get_public_key(key_name)

        cert = RSAPublicCertificate(rsa_key, purpose = purpose, version=version, number = number, autosign=False)
        signature = self._crypto_cm.sign_rsassa_pss(key_name_signing, cert._generate_signed_info())
        cert._RSAPublicCertificate__rsa_signature = signature[::-1]
        return cert

    def _generate_content(self, cert):

        cert_str = str(cert)
        content = "# " + cert_str.replace("\n", "\n# ")
        content += "\ncertificate = bytes([\n"
        name = cert.certificate_purpose.name + "_CERT"
        content += self._print_bytes(name, bytes(cert))
        content += "])\n"
        return content

    def write_content_to_file(self, base_filename, data_content):
        content = ""

        # Build the C content
        content += self.PYTHON_HEADER
        content += data_content

        filename = "{}".format(base_filename)
        # write the C content
        print("Writing {}...".format(filename))
        with open(filename, "wt", newline='\n') as ostream:
            ostream.write(content)

    def generate(self, filename, fingerprint_filename = None, purpose=CertificatePurpose.VENDOR, cert_number = 1, cert_version = 0):
        """Generates the C .h contents file.
        """

        key_name = KeyName.VENDOR_PAIR if purpose==CertificatePurpose.VENDOR else KeyName.SENSOR_PAIR
        cert = self._generate_certificate(key_name, KeyName.VENDOR_PAIR, purpose, cert_version, cert_number)
        fingerprint = CryptoHelper().get_sha256(bytes(cert))
        content = self._generate_content(cert)
        self.write_content_to_file(filename, content)

        #write fingerprint
        if fingerprint_filename:
            # csv header : certificate authority, purpose, certificate number, certificate version, fingerprint
            content = "{}, {}, {}, {}, {}\n".format(cert.certificate_auth_id.name, cert.certificate_purpose.name, cert.certificate_number, cert.certificate_version, fingerprint.hex())
            print("Writing {}...".format(fingerprint_filename))
            with open(fingerprint_filename, "at", newline='\n') as ostream:
                ostream.write(content)


# Create the argument parser
parser = argparse.ArgumentParser(prog='generate_depu_certificates',
    description='Generate content file for Depu App containing all key information')
#parser.add_argument('-v', '--verbose', default=False, action='store_true', help='Enable debug output')
parser.add_argument('-k', '--key_set', choices=['eval', 'test'], required=True, help='Key set name')
parser.add_argument('-o', '--output', required=True, help='Output file')
parser.add_argument('-f', '--fingerprint', required=False, help='Output fingerprint file')
parser.add_argument('-c', '--cert_version', required=True, help='Vendor certificate version')
parser.add_argument('-n', '--cert_number', required=True, help='Vendor certificate number')
parser.add_argument('-p', '--purpose', choices=['sensor', 'vendor'], required=True, help='purpose of the certificate')

# Parse the command line arguments
args = parser.parse_args()

generator = DepuCertGenerator(args.key_set)

purpose = CertificatePurpose.VENDOR if args.purpose=='vendor' else CertificatePurpose.SENSOR

# Generate ASM, C and Python header files
generator.generate(args.output, fingerprint_filename = args.fingerprint, purpose=purpose, cert_number=int(args.cert_number,0), cert_version=int(args.cert_version,0))


