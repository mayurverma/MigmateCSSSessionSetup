#######################################################################################
# Copyright 2018 ON Semiconductor.  All rights reserved.
#
# This software and/or documentation is licensed by ON Semiconductor under limited
# terms and conditions.  The terms and conditions pertaining to the software and/or
# documentation are available at http://www.onsemi.com/site/pdf/ONSEMI_T&C.pdf
# ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Softwar").
# Do not use this software and/or documentation unless you have carefully read and
# you agree to the limited terms and conditions.  By using this software and/or
# documentation, you agree to the limited terms and conditions.
########################################################################################
#
# Generates C header files from a set of IPXACT description files.
#
# Each IPXACT file is parsed and then a corresponding C header file is generated that
# provides e.g. overlay structures, register masks, field width and bit shifts.
#
########################################################################################
import argparse
import configparser
import os
import re
import sys

# Add Python libraries to the import search path
rootdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(os.path.join(rootdir, 'contrib', 'ipyxact'))
sys.path.append(os.path.join(rootdir, 'contrib', 'pyyaml'))
from ipyxact import ipyxact

class GeneratorBase():

    ASM_HEADER = \
        ';***********************************************************************************\n' \
        '; Copyright 2018 ON Semiconductor.  All rights reserved.\n' \
        ';\n' \
        '; This software and/or documentation is licensed by ON Semiconductor under limited\n' \
        '; terms and conditions. The terms and conditions pertaining to the software and/or\n' \
        '; documentation are available at http://www.onsemi.com/site/pdf/ONSEMI_T&C.pdf\n' \
        '; ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Software").\n' \
        '; Do not use this software and/or documentation unless you have carefully read and\n' \
        '; you agree to the limited terms and conditions. By using this software and/or\n' \
        '; documentation, you agree to the limited terms and conditions.\n' \
        ';*************************************************************************************\n' \
        '\n' \
        ';!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' \
        '; DO NOT EDIT - This file is auto-generated by the generate_headers.py script\n' \
        ';!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n'

    ASM_FOOTER = \
        '\n' \
        '                END\n'

    C_HEADER = \
        '#ifndef {0}_H\n' \
        '#define {0}_H\n' \
        '//***********************************************************************************\n' \
        '/// \\file\n' \
        '///\n' \
        '/// Hardware block register definitions.\n' \
        '///\n' \
        '//***********************************************************************************\n' \
        '// Copyright 2018 ON Semiconductor.  All rights reserved.\n' \
        '//\n' \
        '// This software and/or documentation is licensed by ON Semiconductor under limited\n' \
        '// terms and conditions. The terms and conditions pertaining to the software and/or\n' \
        '// documentation are available at http://www.onsemi.com/site/pdf/ONSEMI_T&C.pdf\n' \
        '// ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Software").\n' \
        '// Do not use this software and/or documentation unless you have carefully read and\n' \
        '// you agree to the limited terms and conditions. By using this software and/or\n' \
        '// documentation, you agree to the limited terms and conditions.\n' \
        '//***********************************************************************************\n' \
        '\n' \
        '// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' \
        '// DO NOT EDIT - This file is auto-generated by the generate_headers.py script\n' \
        '// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n'

    C_FOOTER = \
        '\n' \
        '#endif /* {}_H */\n'

# Memory map generator class
class MemoryMapGenerator(GeneratorBase):

    def __init__(self, directory, prefix, debug=False):
        self._directory = directory
        self._prefix = prefix
        self._debug = debug
        self._pattern = re.compile(r"\( ?(\w+) ?\+ ?(0x[0-9a-fA-F]+) ?\)")

    def generate(self, filename):
        config = configparser.ConfigParser()
        config.read(filename)

        # build the ASM memory map content
        content = self.ASM_HEADER
        for section in config.sections():
            content += '\n'
            content += ';-------------------------------------------------------------------------------\n'
            content += ';    {} Section\n'.format(section)
            content += ';-------------------------------------------------------------------------------\n'
            content += '\n'
            for (key, value) in config[section].items():
                #content += '{:30s}  EQU  {}\n'.format(key.upper(), hex(int(value)))
                content += '{:30s}  EQU  {}\n'.format(key.upper(), value)
        content += self.ASM_FOOTER

        # write the ASM memory map content
        asm_memmap = '{}/{}memmap.inc'.format(self._directory, self._prefix)
        with open(asm_memmap, "wt") as ostream:
            ostream.write(content)

        # build the C memory map content
        include_guard = '{}MEMMAP'.format(self._prefix)
        content = self.C_HEADER.format(include_guard)
        for section in config.sections():
            content += '\n'
            content += '//------------------------------------------------------------------------------\n'
            content += '//    {} Section\n'.format(section)
            content += '//------------------------------------------------------------------------------\n'
            content += '\n'
            for (key, value) in config[section].items():
                if value.startswith('0x'):
                    content += '#define {:30s}  {}UL\n'.format(key.upper(), value)
                else:
                    # If (base + offset) arithmetic is being done
                    match = self._pattern.match(value)
                    if match is not None:
                        # Use unsigned arithmetic
                        content += '#define {:30s}  ({} + {}U)\n'.format(key.upper(), match.group(1), match.group(2))
                    else:
                        content += '#define {:30s}  {}\n'.format(key.upper(), value)
        content += self.C_FOOTER.format(include_guard)

        # write the C memory map content
        c_memmap = '{}/{}memmap.h'.format(self._directory, self._prefix)
        with open(c_memmap, "wt") as ostream:
            ostream.write(content)

# Header file generator base class
class HeaderGeneratorBase(GeneratorBase):

    def __init__(self, directory, debug=False):
        self._directory = directory
        self._debug = debug

    def generate(self, module, component):
        filename = self._get_filename(module)
        component_name = module.upper()
        block = component.memoryMaps.memoryMap[0].addressBlock[0]
        register_list = sorted(block.register, key=lambda x: x.addressOffset)
        with open(filename, "wt") as ostream:
            ostream.write(self._get_content(component_name, block.name.upper(), register_list))

    def _get_filename(self, module):
        raise NotImplementedError

    def _get_content(self, component_name, block_name, register_list):
        raise NotImplementedError


# Assembler header file generator class
class AsmHeaderGenerator(HeaderGeneratorBase):

    def __init__(self, directory, debug=False):
        # Save the constructor arguments
        super().__init__(directory, debug)

    def _generate_register_addresses(self, component_name, block_name, register_list):
        content = '\n'
        content += ';-------------------------------------------------------------------------------\n'
        content += ';                                  Register Addresses\n'
        content += ';-------------------------------------------------------------------------------\n'
        content += '\n'
        offset = 0
        base_address_name = '{}_REG_BASE'.format(component_name)
        for register in register_list:
            register_name = '{}_{}'.format(block_name, register.name.upper())
            content += '{:30s}  EQU  ({} + {})\n'.format(register_name, base_address_name, hex(register.addressOffset))
        return content

    def _generate_register_fields(self, component_name, register_list):
        content = '\n'
        content += ';-------------------------------------------------------------------------------\n'
        content += ';                                  Register Fields\n'
        content += ';-------------------------------------------------------------------------------\n'
        for register in register_list:
            register_name = '{}_{}'.format(component_name, register.name.upper())
            value = hex(register.addressOffset)
            for field in register.field:
                fieldName = '{}_{}'.format(register_name, field.name.upper())
                content += '\n'
                content += '{0:50s}  EQU  {1}\n'.format(fieldName + '__SIZE', field.bitWidth)
                content += '{0:50s}  EQU  {1}\n'.format(fieldName + '__SHIFT', field.bitOffset)
                content += '{0:50s}  EQU  (((1 << {1}__SIZE) - 1) << {1}__SHIFT)\n'.format(fieldName + '__MASK', fieldName)
        return content

    def _get_filename(self, module):
        return '{}/{}.inc'.format(self._directory, module)

    def _get_content(self, component_name, block_name, register_list):
        content = self.ASM_HEADER.format(component_name)
        content += self._generate_register_addresses(component_name, block_name, register_list)
        content += self._generate_register_fields(component_name, register_list)
        content += self.ASM_FOOTER.format(component_name)
        return content


# C header file generator class
class CHeaderGenerator(HeaderGeneratorBase):

    _REGISTER_TYPE = {32 : 'uint32_t'}

    _REGISTER_ACCESS = {
        '' : '__IOM',
        'read-write' : '__IOM',
        'read-only' : '__IM',
        'write-only' : '__OM',
        'writeOnce' : '__OM',
        'read-writeOnce' : '__IOM'
    }

    def __init__(self, directory, debug=False):
        super().__init__(directory, debug)

    def _generate_constants(self, component_name, register_list):
        content = '\n'
        content += '//------------------------------------------------------------------------------\n'
        content += '//                                  Constants\n'
        content += '//------------------------------------------------------------------------------\n'
        content += '\n'
        content += '// Register address definitions (offsets relative to register base)\n'
        content += '\n'
        base_address_name = '{}_REG_BASE'.format(component_name)
        for register in register_list:
            register_name = '{}_{}'.format(component_name, register.name.upper())
            content += '#define {:50s} ({} + 0x{:04X}U)\n'.format(register_name, base_address_name, register.addressOffset)
        content += '\n'
        content += '// Register field definitions\n'
        for register in register_list:
            register_name = '{}_{}'.format(component_name, register.name.upper())
            for field in register.field:
                fieldName = '{}_{}'.format(register_name, field.name.upper())
                content += '\n'
                content += '#define {:50s} {}U\n'.format(fieldName + '__SIZE', field.bitWidth)
                content += '#define {:50s} {}U\n'.format(fieldName + '__SHIFT', field.bitOffset)
                content += '#define {0:50s} (((uint32_t)((1UL << {1}__SIZE) - 1U)) << {1}__SHIFT)\n'.format(fieldName + '__MASK', fieldName)
        return content

    def _generate_types(self, block_name, register_list):
        content = '\n\n'
        content += '//------------------------------------------------------------------------------\n'
        content += '//                                  Types\n'
        content += '//------------------------------------------------------------------------------\n'
        content += '\n'
        content += 'typedef struct\n'
        content += '{\n'
        offset = 0
        reserved = 1
        for register in register_list:
            # Registers are 32bit aligned so no need to allow for alignment issues
            if register.addressOffset != offset:
                size = register.addressOffset - offset
                content += '    {:5s} {:8s} reserved{}[{}];\n'.format(self._REGISTER_ACCESS['read-only'], self._REGISTER_TYPE[32], reserved, size // 4)
                offset += size
                reserved += 1
            content += '    {:5s} {:8s} {};\n'.format(self._REGISTER_ACCESS[register.access], self._REGISTER_TYPE[register.size], register.name)
            offset += register.size // 8
        content += '}} {}_REGS_T;\n'.format(block_name)
        return content

    def _get_filename(self, module):
        return '{}/{}.h'.format(self._directory, module)

    def _get_content(self, component_name, block_name, register_list):
        content = self.C_HEADER.format(component_name)
        content += self._generate_constants(component_name, register_list)
        content += self._generate_types(block_name, register_list)
        content += self.C_FOOTER.format(component_name)
        return content


# List of AR0280 modules
all_modules = ['crypto_icore', 'crypto_otpm', 'crypto_vcore', 'debug_uart', 'mcu_sysctrl', 'patcher']

# Create the argument parser
parser = argparse.ArgumentParser(prog='generate_headers',
    description='Generate C header files for a list of IPXACT files')
parser.add_argument('-d', '--debug', default=False, action='store_true', help='Enable debug output')
parser.add_argument('-m', '--memmap', required=True, help='Memory map configuration ini file')
parser.add_argument('-i', '--input', required=True, help='Input directory for IPXACT files')
parser.add_argument('-o', '--output', required=True, help='Output directory for header files')
parser.add_argument('modules', nargs='*', help='List of IPXACT modules')

# Parse the command line arguments
args = parser.parse_args()
if 0 == len(args.modules):
    modules = all_modules
else:
    modules = args.modules

# Create the memory map generator and then generate the associated header files
print('Generating memory map...')
memmap = MemoryMapGenerator(args.output, 'AR0820_', args.debug)
memmap.generate(args.memmap)

# Create the header generators
print('Generating hardware blocks...')
c_generator = CHeaderGenerator(args.output, args.debug)
asm_generator = AsmHeaderGenerator(args.output, args.debug)

# For each module in the modules list
for module in modules:
    # Parse the IPXACT file
    component = ipyxact.Component()
    component.load('{}/{}.xml'.format(args.input, module))

    # Generate the C header files
    c_generator.generate(module, component)

    # Generate the ASM header files
    asm_generator.generate(module, component)
