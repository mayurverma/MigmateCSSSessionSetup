#######################################################################################
# Copyright 2018 ON Semiconductor.  All rights reserved.
#
# This software and/or documentation is licensed by ON Semiconductor under limited
# terms and conditions.  The terms and conditions pertaining to the software and/or
# documentation are available at http://www.onsemi.com/site/pdf/ONSEMI_T&C.pdf
# ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Softwar").
# Do not use this software and/or documentation unless you have carefully read and
# you agree to the limited terms and conditions.  By using this software and/or
# documentation, you agree to the limited terms and conditions.
########################################################################################
#
# Generates C header files with the key database for Depu App
#
########################################################################################
import argparse
import csv
import os
import sys
import struct
from importlib import import_module

# Add Python libraries to the import search path
rootdir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
scripts_dir = os.path.join(rootdir, 'scripts')
test_scripts_dir = os.path.join(rootdir, 'test/scripts')
depu_app_dir = os.path.join(rootdir, 'src', 'DepuApp', 'src')

if scripts_dir not in sys.path:
    sys.path.append(scripts_dir)

if test_scripts_dir not in sys.path:
    sys.path.append(test_scripts_dir)

if depu_app_dir not in sys.path:
    sys.path.append(depu_app_dir)

from crypto_helper import CryptoHelper
from crypto_services_client import CryptoServicesClient
from rsa_public_certificate import RSAPublicCertificate, CertificatePurpose
from nvm_record import NvmRecordRSAPrivateKey, NvmRecordRSAPublicCert
from host_command_provision_asset import HostCommandProvisionAssetParams
from key_name import KeyName
from root_of_trust import RootOfTrust
from branch_properties import BranchProperties
from toolbox import Toolbox

class DepuLibAsset():

    def __init__(self, asset_id,   root_of_trust, payload):
        self.__asset_id = asset_id
        self.__root_of_trust = root_of_trust
        self.__payload = payload

    def __bytes__(self):
        data = struct.pack("<LHH{}s".format(len(self.__payload)),
            self.__asset_id,
            self.__root_of_trust,
            0,
            self.__payload)

        return data



class DepuContentGenerator():
    """Depu content generator class
    """

    PYTHON_HEADER = \
        '####################################################################################\n' \
        '# Copyright 2018 ON Semiconductor.  All rights reserved.\n' \
        '#\n' \
        '# This software and/or documentation is licensed by ON Semiconductor under limited\n' \
        '# terms and conditions. The terms and conditions pertaining to the software and/or\n' \
        '# documentation are available at http://www.onsemi.com/site/pdf/ONSEMI_T&C.pdf\n' \
        '# ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Software").\n' \
        '# Do not use this software and/or documentation unless you have carefully read and\n' \
        '# you agree to the limited terms and conditions. By using this software and/or\n' \
        '# documentation, you agree to the limited terms and conditions.\n' \
        '#\n' \
        '####################################################################################\n' \
        '\n' \
        '#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' \
        '# DO NOT EDIT - This file is auto-generated by the generate_depu_contents.py script\n' \
        '#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' \
        '\n'

    def __init__(self, key_set_name,   debug=False):

        self._crypto = CryptoServicesClient(BranchProperties.get_product_prefix(), root_of_trust = RootOfTrust.CD, key_set_name = key_set_name)
        self._crypto_cm = CryptoServicesClient(BranchProperties.get_product_prefix(), root_of_trust = RootOfTrust.CM, key_set_name = key_set_name)

        self._debug = debug

    def _bytes_to_hex(self, data, comment = False):
        """prints bytes to ascii
        """
        result = ""
        for index, databyte in enumerate(data):
            if (index % 16) == 0:
                result += "\n#   " if comment else " \n    "
            else:
                result += " "
            result += "0x{:02x},".format(databyte)

        return result

    def _bytes_to_csv(self, data, initial_offset = 0):
        " Formats byte array into csv format as a set 0f 16-bit writes"
        page_size = 1024
        length = 2
        base_address = 0xF100
        assert initial_offset < page_size, "initial_offset too big {} > {}".format(initial_offset, page_size)
        offset = initial_offset
        page = 0
        result = ""
        # Write to page register, selecting first page of shared memory
        result += "WRITE,0xF00C,0x0000,#Write to page register, selecting first page of shared memory\n"
        for x in  range(int(len(data))//length):
            value = int(data[x*length]) + int((data[(x*length)+1] << 8))
            result += "WRITE,0x{:04X},0x{:04X}\n".format(base_address + (offset % page_size),value)
            offset += 2
            if (offset // page_size) != page:
                page = offset // page_size
                result += "WRITE,0xF00C,0x{:04x},#Write to page register, selecting page {} of shared memory\n".format(page, page)
        if (0 != len(data)%length):
            value = data[x*length]
            result += "WRITE,0x{:04X},0x{:04X}\n".format(base_address + (offset % page_size),value)

        if page != 0:
            result += "WRITE,0xF00C,0x0000,#Write to page register, selecting first page of shared memory\n"

        return result

    def _print_bytes(self, name, params_bytes):

        content = ""
        content += "\n# {} {} bytes\n".format(name, len(params_bytes))
        content += self._bytes_to_hex(params_bytes)
        content += "\n"

        return content

    def _generate_cert_contents(self, cert, asset_id):

        content = ""
        root_of_trust = 0 # RoT CM

        asset = NvmRecordRSAPublicCert(cert)
        asset_payload = self._crypto_cm.encrypt_asset(asset_id, bytes(asset))
        asset = DepuLibAsset(asset_id, root_of_trust, asset_payload)

        name = cert.certificate_purpose.name + "_CERT"
        content += self._print_bytes(name, bytes(asset))
        return content


    def _generate_rsa_priv_contents(self, key_name, asset_id):

        content = ""
        root_of_trust = 0 # RoT CM

        asset_payload = self._crypto_cm.encrypt_private_key(key_name, asset_id)
        asset = DepuLibAsset(asset_id, root_of_trust, asset_payload)

        name = key_name.name.replace("_PAIR", "_PRIV")
        content += self._print_bytes(name, bytes(asset))
        return content

    def _generate_aes_contents(self, key_name, asset_id):

        content = ""
        root_of_trust = 0 # RoT CM

        asset_payload = self._crypto_cm.encrypt_private_key(key_name, asset_id)
        asset = DepuLibAsset(asset_id, root_of_trust, asset_payload)


        content += self._print_bytes(key_name.name, bytes(asset))
        return content

    def _generate_kpicv_contents(self, key_name, hbk0):

        content = ""
        root_of_trust = 0 # RoT CM
        asset_id = int.from_bytes(hbk0, 'little')
        asset_payload = self._crypto.encrypt_private_key(key_name, asset_id)
        asset = asset_payload

        content += self._print_bytes(key_name.name, bytes(asset))
        return content

    def write_content_to_file(self, base_filename, data_content):
        content = ""

        # Build the C content
        content += self.PYTHON_HEADER
        content += "DepuAppContent = bytes([\n"
        content += data_content
        content += "\n])\n"

        filename = "{}".format(base_filename)
        # write the C content
        print("Writing {}...".format(filename))
        with open(filename, "wt", newline='\n') as ostream:
            ostream.write(content)


    def generate(self, filename_csv, filename_py, key_set_name):
        """Generates the C .h contents file.
        """

        vendor_cert_bytes = import_module('depu_app_vendor_cert_{}'.format(key_set_name)).certificate
        sensor_cert_bytes = import_module('depu_app_sensor_cert_{}'.format(key_set_name)).certificate
        vendor_cert = RSAPublicCertificate.get_and_validate_certificate_from_bytes(None, vendor_cert_bytes) #auto-signed so no validation key
        sensor_cert = RSAPublicCertificate.get_and_validate_certificate_from_bytes(vendor_cert.rsa_public_key, sensor_cert_bytes)

        rot_cm_public = self._crypto_cm.get_public_key(KeyName.ROT_CM_PAIR)
        hbk0 = CryptoHelper().hbk_gen(rot_cm_public, truncated=True)

        content = self._generate_kpicv_contents(KeyName.KPICV, hbk0)
        content += self._generate_aes_contents(KeyName.KCP, 2)

        content += self._bytes_to_hex(hbk0)

        content += self._bytes_to_hex(CryptoHelper().generate_random_aes_key(size = 16))

        content += self._generate_cert_contents(sensor_cert, 3)

        content += self._generate_cert_contents(vendor_cert, 4)

        content += self._generate_rsa_priv_contents(KeyName.SENSOR_PAIR, 5)

        if filename_py:
            self.write_content_to_file(filename_py, content)

        DepuAppContent = eval('bytes([' + content + '])')

        # write the CSV content
        if filename_csv:
            print("Writing {}...".format(filename_csv))
            checksum = Toolbox().calculate_checksum(DepuAppContent)
            block_length_bytes = len(DepuAppContent)
            header = block_length_bytes.to_bytes(2, 'little') + checksum.to_bytes(2, 'little')
            content = self._bytes_to_csv(header + DepuAppContent, 0x4)
            with open(filename_csv, "wt", newline='\n') as ostream:
                ostream.write(content)



# Create the argument parser
parser = argparse.ArgumentParser(prog='generate_depu_contents',
    description='Generate content file for Depu App containing all key information')
#parser.add_argument('-v', '--verbose', default=False, action='store_true', help='Enable debug output')
parser.add_argument('-k', '--key_set', choices=['eval', 'test'], required=True, help='Key set name')
parser.add_argument('-o', '--output_csv', required=False, help='Output csv file name')
parser.add_argument('-p', '--output_py', required=False, help='Output py file name')

# Parse the command line arguments
args = parser.parse_args()

generator = DepuContentGenerator(args.key_set)

# Generate ASM, C and Python header files
generator.generate(args.output_csv, args.output_py, args.key_set)


