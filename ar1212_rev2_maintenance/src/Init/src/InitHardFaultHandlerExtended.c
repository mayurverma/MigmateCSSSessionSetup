//******************************************************************************
/// \file
///
/// This file implements the Hard Fault handler for debug builds
///
/// \addtogroup init
/// @{
//******************************************************************************
// Copyright 2018 ON Semiconductor. All rights reserved. This software and/or
// documentation is licensed by ON Semiconductor under limited terms and
// conditions. The terms and conditions pertaining to the software and/or
// documentation are available at http://www.onsemi.com/site/pdf/ONSEMI_T&C.pdf
// ("ON Semiconductor Standard Terms and Conditions of Sale, Section 8 Software").
// Do not use this software and/or documentation unless you have carefully read
// and you agree to the limited terms and conditions. By using this software
// and/or documentation, you agree to the limited terms and conditions.
//******************************************************************************

#include <string.h>

#include "bsv_api.h"

#include "Common.h"
#include "AR0820.h"
#include "SystemMgr.h"
#include "Diag.h"
#include "OtpmDrv.h"
#include "CommandDrv.h"
#include "WatchdogDrv.h"
#include "Interrupts.h"

#include "InitInternal.h"

//------------------------------------------------------------------------------
//                                  Types
//------------------------------------------------------------------------------

/// Represents a processor state fatal error cause
typedef enum
{
    INIT_HARD_FAULT_PROCESSOR_STATE_CONTEXT_PSP_IN_USE = 0x01U,     ///< Process stack point in use - unexpected
    INIT_HARD_FAULT_PROCESSOR_STATE_CONTEXT_THUMB_CLEAR = 0x02U,    ///< Thumb bit clear - wrong processor state
} InitHardFaultProcessorStateContextT;

//------------------------------------------------------------------------------
//                                  Constants
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//                                  Locals
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//                                  Exports
//------------------------------------------------------------------------------

/// Handles a hard fault (invoked by assembler wrapper)
///
/// Hard faults can happen for the following reasons:
///
/// | Fault Class  | Fault Condition                                            |
/// |:------------:|:-----------------------------------------------------------|
/// |Memory related| 1. Bus error (can be program accesses or data accesses,    |
/// |              |    also referred to as bus faults in Cortex-M3):           |
/// |              |    a. Bus error generated by bus infrastructure because of |
/// |              |       an invalid address during bus transaction            |
/// |              |    b. Bus error generated by bus slave                     |
/// |              | 2. Attempt to execute the program from a memory region     |
/// |              |    marked as nonexecutable                                 |
/// | Program error| 3. Execution of undefined instruction                      |
/// |(usage faults)| 4. Trying to switch to ARM state (Cortex-M0+ only supports |
/// |              |    Thumb instructions)                                     |
/// |              | 5. Attempt to generate an unaligned memory access (not     |
/// |              |    allowed in ARMv6-M)                                     |
/// |              | 6. Attempt to execute an SVC when the SVC exception        |
/// |              |    priority level is the same or lower than the current    |
/// |              |    exception level                                         |
/// |              | 7. Invalid EXC_RETURN value during exception return        |
/// |              | 8. Attempt to execute a breakpoint instruction (BKPT) when |
/// |              |    debug is not enabled (no debugger attached)             |
///
/// This 'extended' hard fault handler is only invoked if a processor data RAM
/// ECC DED fault did not trigger the hard fault. Therefore the extended handler
/// is free to use the stack and other processor data RAM regions.
///
/// \param[in] FramePtr     Points to the stacked exception frame
/// \param[in] LinkReg      The current LR value
/// \param[in] ControlReg   The current CONTROL value
/// \returns Never
///
void InitHardFaultHandler(uint32_t* FramePtr, uint32_t LinkReg, uint32_t ControlReg)
{
    SystemMgrCssFaultT fault = SYSTEM_MGR_CSS_FAULT_NONE;
    uint32_t context = 0U;
    uint16_t info = 0U;
    ErrorT result;
    bool isPending;

    xPSR_Type* xPSR = (xPSR_Type*)&FramePtr[7];

    DiagPrintf("!!! HARDFAULT !!!\n");
    DiagPrintf("R0  = 0x%08lx R1 = 0x%08lx R2 = 0x%08lx R3   = 0x%08lx\n",
        FramePtr[0], FramePtr[1], FramePtr[2], FramePtr[3]);
    DiagPrintf("R12 = 0x%08lx LR = 0x%08lx PC = 0x%08lx xPSR = 0x%08lx\n",
        FramePtr[4], FramePtr[5], FramePtr[6], FramePtr[7]);
    DiagPrintf("currLR = 0x%08lx\n", LinkReg);
    DiagPrintf("Exception# = 0x%08x\n", xPSR->b.ISR);

    //
    // Attempt to determine the cause of the HardFault
    //

    // 1. RAM ECC DED?
    // - this is detected by the assembler HardFault handler and so cannot
    //   be detected here

    // 2. ROM ECC DED?
    (void)InterruptsIsInterruptPending(INTERRUPT_CYBER_ROM_DED_17, &isPending);
    if (isPending)
    {
        fault = SYSTEM_MGR_CSS_FAULT_ROM_ECC_FAILURE;
        DiagPrintf("ROM ECC DED\n");
    }
    // 3. Invalid Thumb state?
    //    - note this MUST be tested after the CC312 software abort case because
    //      the 'bad' Thumb bit is used to trigger the exception.
    else if (0U == xPSR->b.T)
    {
        // The M0+ only supports Thumb instructions. If the Thumb bit is
        // clear it indicates processor state corruption.
        fault = SYSTEM_MGR_CSS_FAULT_PROCESSOR_STATE;
        context = (uint32_t)INIT_HARD_FAULT_PROCESSOR_STATE_CONTEXT_THUMB_CLEAR;

        DiagPrintf("Thumb bit clear, wrong ARM state\n");
    }
    // 4. Invalid processor state?
    else if (0U != ControlReg)
    {
        // Non-zero CONTROL reg indicates the Process stack pointer is in use
        // which is not expected. This could be because LR has been modified
        // incorrectly during a previous exception handler, or stack corruption
        // has taken place which incorrectly modified the value of EXC_RETURN.
        fault = SYSTEM_MGR_CSS_FAULT_PROCESSOR_STATE;
        context = (uint32_t)INIT_HARD_FAULT_PROCESSOR_STATE_CONTEXT_PSP_IN_USE;

        DiagPrintf("Control is non-zero (0x%08x)\n", ControlReg);
    }
    // 5. OTPM ECC DED?
    else
    {
        OtpmDrvErrorT otpmDrvError;

        result = OtpmDrvGetLastError(&otpmDrvError);
        if ((ERROR_SUCCESS == result) &&
            (!otpmDrvError.isCorrectable))
        {
            fault = SYSTEM_MGR_CSS_FAULT_OTPM_ERROR;
            // OTPM driver reports the byte address, convert to long word address
            context = (uint32_t)otpmDrvError.errorAddress / sizeof(uint32_t);

            DiagPrintf("OTPM DED error @ 0x%08x\n", context);
        }
    }
    // 6. Unknown...
    if (SYSTEM_MGR_CSS_FAULT_NONE == fault)
    {
        // Unknown fault - could be one of the following:
        // - Bus error due to invalid access (trigged by MPU)
        // - Execution of an undefined instruction
        // - Unaligned memory access
        fault = SYSTEM_MGR_CSS_FAULT_HARDFAULT;
        info = (uint16_t)FramePtr[6];   // PC [15..0]
        context = FramePtr[6] >> 16U;   // PC [25..16] - note truncated to 10 bits when written to hardware register
    }

    InitHardFaultShutdown((uint32_t)fault, context, info);
}

/// @} endgroup init

